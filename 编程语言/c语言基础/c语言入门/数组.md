---
tags:
  - c语言
---

## 一维数组的创建和初始化
1. 数组是相同类型元素的集合
2. 数组的创建
```c
type_t arr_name [const_n];
// 数组类型
//数组名
//数组长度  （c99之前，只能为常量或常量表达式）
```
3. 数组的初始化（给数组赋值）
```c
char byg[4]={"z","s","x"};  //简单的字符数组初始化
```
- 不完全初始化：剩余元素默认是0
4. 一维数组的使用[]下标引用操作符
```c
printf("her last name %c",byg[0]);
```
5. 可用于计算数组长度的方法
```c
int size=sizeof(byg)/sizeof(byg[0]);
3```

6. 一维数组在内存中的存储
7. ```c
   printf("&byg[%d]=%p",i,&byg[i]);
   ```
   - 数组在内存中连续存储


## 二维数组创建和初始化
1. 创建
```c
int arr[3][4];
```
2. 初始化
```c
int arr[][4]; //二维数组行可以省略，列不能省略
```
- 分组放置数据
	```c
	int arr[3][4]={{1,2},{3,4},{5,6}}; //分别放置在不同行，末尾补零
	```
3. 输出一个二维数组
```c
for(int i=0;i<3;i++){
	for(int j=0;j<4;j++);
	printf("arr[i][j]=%d",arr[i][j]);  //循环遍历数组
}
```
4. 二维数组和一位数组的关系
	- 二维数组可以看作一位数组的数组
	- 可以关联到矩阵，每一个一位数组都是一个向量
5. 二维数组在内存中的存储也是连续的

## 数组越界
1. 数组越界访问：超出了数组合法空间的访问
	- 编译器不一定报错，需要自己检查
```c
int main(){   //越界例子
	int arr[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
	for (int i=0;i<3;i++){
		for (int j=0;j<=4;j++){   //错误访问到数组的下一行
			printf("%d",arr[i][j])
		}
	}
}
```

## 数组作为函数传参
1. 将数组作为参数传给函数，如冒泡排序
	- 数组在传参的时候只需要给数组名 （bubble(arrr)函数调用）
2. 冒泡排序示例
```c
bubble_sort(int arr[]){   //函数声明，arr退化成指针
	for (int i=0;i<size-1;i++){
		for(int j=0;j<size-i-j;j++){
			if(arr[j]>arr[j+1]){   //相邻元素比较
			temp=;
			}
		}
	}
}
```

```c
void bubble(int arr[], int n);  // 声明/定义
// 或者
void bubble(int *arr, int n);   // 等价写法

```
**函数声明中传的是首元素的地址**

### 数组名是什么？
```c
int main(){
	printf("%p",arr);
	printf("%p",&arr[0]);
	printf("%p",&arr);      //三个值均相等
}
```
**结论：数组名是首元素的地址**[[指针#^062dc4|数组和指针的关系]]
```c
int n=sizeof(arr);
printf("%d",n);    //此时n=数组的长度而不是地址
```
*两个例外*
1. sizeof（数组名）此时数组名表示整个数组，计算这个数组的大小 ^39d65e
2. &数组名，此时也表示整个数组，取出整个数组的地址
```c
printf("%p",&arr);
printf("%p",&arr+1);  //加1之后地址直接越过整个数组
```

**二维数组的数组名**
- 与一维数组基本相同
- 数组名表示第一行的地址

**sizeof计算数组的行与列长度**
```c
int arr[3][4];
printf("%d",sizeof(arr[0])/sizeof(arr[0][0]));
printf("%d",sizeof(arr)/sizeof(arr[0]));  //sizeof数组名得到整个二维数组的长度
```
